---
import data from '../data/messageData.json' assert { type: 'json' };
---
<div class="chartOptions">
    <label for="interval">Group by:</label>
    <select id="interval">
        <option value="day">Day</option>
        <option value="week" selected="selected">Week</option>
        <option value="month">Month</option>
    </select>

    <label for="windowSize">Window Size:</label>
    <input id="windowSize" type="number" value="3" min="1" />

    <label for="channelFilter">Isolate channel:</label>
    <select id="channelFilter">
        <option value="">All Channels</option>
    </select>
</div>

<div id="chart" data-messages={JSON.stringify(data)}>

    <div id="tooltip"></div>
</div>

<div id="legend"></div>

<script>
import * as d3 from 'd3';

const chartDiv = document.getElementById('chart') as HTMLDivElement;
const intervalSelect = document.querySelector('#interval') as HTMLSelectElement;
const windowSizeInput = document.querySelector('#windowSize') as HTMLInputElement;
const channelFilterSelect = document.querySelector('#channelFilter') as HTMLSelectElement;
const legendDiv = document.getElementById('legend') as HTMLDivElement;
const tooltip = document.getElementById('tooltip') as HTMLDivElement;

if (!chartDiv || !intervalSelect || !windowSizeInput || !channelFilterSelect || !legendDiv || !tooltip)
    throw new Error('Missing required elements');

interface rawDataType {
    channelName: string;
    date: Date;
    count: number;
}

const rawData: rawDataType[] = JSON.parse(chartDiv.dataset.messages!);
chartDiv.removeAttribute('data-messages');

rawData.forEach(d => {
    d.date = new Date(d.date);
    d.count = +d.count;
});

const earliestDate = d3.min(rawData, d => d.date) ?? new Date();
const latestDate = d3.max(rawData, d => d.date) ?? new Date();

const allChannelNames = Array.from(new Set(rawData.map(d => d.channelName)));
allChannelNames.forEach(ch => {
    const opt = document.createElement('option');
    opt.value = ch;
    opt.textContent = ch;
    channelFilterSelect.appendChild(opt);
});

let width = chartDiv.clientWidth;
let height = Math.floor(width * 0.6);
const margin = {
    top: 20,
    right: 20,
    bottom: 30,
    left: 50
};

const canvas = d3.select(chartDiv)
    .append('canvas')
    .attr('width', width)
    .attr('height', height);

const context = canvas.node()!.getContext('2d')!;

let xScale: d3.ScaleTime<number, number, never>, yScale: d3.ScaleLinear<number, number, never>;
let xOrig: d3.ScaleTime<number, number, never>, yOrig: d3.ScaleLinear<number, number, never>;

let focusedChannel: string | null = null;
let focusLock = false;

// array of arrays, each sub-array is one channel's timeseries
function groupDataByInterval (data: rawDataType[], interval: string) {
    const truncatedData = data.map(d => {
        const dt = new Date(d.date);
        let newDt = dt;
        if (interval === 'day') {
            newDt = new Date(dt.getFullYear(), dt.getMonth(), dt.getDate());
        } else if (interval === 'week') {
            const day = dt.getDay(); // 0 (Sun) - 6 (Sat)
            newDt = new Date(dt);
            newDt.setDate(dt.getDate() - day);
            newDt.setHours(0, 0, 0, 0);
        } else if (interval === 'month') {
            newDt = new Date(dt.getFullYear(), dt.getMonth(), 1);
        }
        return {
            date: newDt,
            count: d.count,
            channelName: d.channelName
        };
    });

    const channelMap = d3.group(truncatedData, d => d.channelName);

    const result: rawDataType[][] = [];
    channelMap.forEach((arr, channelName) => {
        const dateMap = d3.rollup(
            arr,
            v => d3.sum(v, d => d.count),
            d => +d.date
        );
        const groupedArray = Array.from(dateMap, ([time, count]) => ({
            date: new Date(time),
            count,
            channelName,
        }));
        groupedArray.sort((a, b) => +a.date - +b.date);
        result.push(groupedArray);
    });
    return result;
}

function movingAverage (series: rawDataType[], windowSize: number) {
    const result: rawDataType[] = [];
    for (let i = 0; i < series.length; i++) {
        const start = Math.max(0, i - (windowSize - 1));
        const window = series.slice(start, i + 1);
        const avg = d3.mean(window, d => d.count) ?? 0;
        result.push({
            ...series[i]!,
            count: avg
        });
    }
    return result;
}

function setupScales (channelsArray: rawDataType[][]) {
    // Flatten for global min/max
    const allPoints = channelsArray.flat();
    const yMax = d3.max(allPoints, d => d.count) ?? 0;

    // Build x/y scales (we'll store original copies for zoom)
    xOrig = d3.scaleTime()
        .domain([earliestDate, latestDate])
        .range([margin.left, width - margin.right]);

    yOrig = d3.scaleLinear()
        .domain([0, yMax]).nice()
        .range([height - margin.bottom, margin.top]);

    xScale = xOrig.copy();
    yScale = yOrig.copy();
}

let colorRange: string[] = [];

function drawLines (channelsArray: rawDataType[][]) {
    context.clearRect(0, 0, width, height);

    const xTicks = xScale.ticks(5);
    const yTicks = yScale.ticks(6);

    // X ticks and labels
    context.beginPath();
    context.strokeStyle = '#bbb';
    xTicks.forEach(t => {
        const tx = xScale(t);
        context.moveTo(tx, height - margin.bottom);
        context.lineTo(tx, height - margin.bottom + 5);
    });
    context.stroke();

    context.textAlign = 'center';
    context.textBaseline = 'top';
    context.fillStyle = '#fff';
    xTicks.forEach(t => {
        const tx = xScale(t);
        context.fillText(d3.utcFormat('%b %d %Y')(t), tx, height - margin.bottom + 8);
    });

    // Y ticks and labels
    context.beginPath();
    context.strokeStyle = '#bbb';
    yTicks.forEach(t => {
        const ty = yScale(t);
        context.moveTo(margin.left, ty);
        context.lineTo(margin.left - 5, ty);
    });
    context.stroke();

    context.textAlign = 'right';
    context.textBaseline = 'middle';
    context.fillStyle = '#fff';
    yTicks.forEach(t => {
        const ty = yScale(t);
        context.fillText(`${t}`, margin.left - 8, ty);
    });

    // Use interpolateRdYlBu for colours
    const channels = channelsArray.map(arr => arr[0]!.channelName).filter(Boolean);
    colorRange = channels
        .map((_, i) => d3.interpolatePuBuGn(i / ((channels.length - 1) || 1)))
        .map(c => d3.color(c)!.brighter(1).toString());
    const color = d3.scaleOrdinal(colorRange).domain(channels);

    // Draw each line
    channelsArray.forEach(series => {
        if (!series.length) return;
        const channel = series[0]!.channelName;
        context.beginPath();
        context.strokeStyle = color(channel);
        context.lineWidth = 2;

        if (focusedChannel && channel !== focusedChannel)
            context.globalAlpha = 0.1; // dim if not focused

        series.forEach((d, i) => {
            const cx = xScale(d.date);
            const cy = yScale(d.count);
            if (i === 0)
                context.moveTo(cx, cy);
            else
                context.lineTo(cx, cy);
        });
        context.stroke();

        context.globalAlpha = 1.0;
    });
}

// Store to easily redraw on zoom 
let currentChannels: rawDataType[][] = [];

const zoomBehavior = d3.zoom()
    .scaleExtent([1, 20])
    .translateExtent([
        [margin.left, margin.top],
        [width - margin.right, height - margin.bottom]
    ])
    .on('zoom', zoomed);

function zoomed (event: any) {
    const transform = event.transform;

    xScale = transform.rescaleX(xOrig);
    yScale = transform.rescaleY(yOrig);

    xScale.domain([
        Math.max(+xOrig.domain()[0]!, +xScale.domain()[0]!),
        Math.min(+xOrig.domain()[1]!, +xScale.domain()[1]!)
    ]);

    drawLines(currentChannels); 
}

d3.select(canvas.node()).call(zoomBehavior as any);

// Tooltip functionality
canvas.on('mousemove', (event) => {
    if (!currentChannels.length) return;
    const [mx, my] = d3.pointer(event, canvas.node());

    let closest = null;
    let minDist = Infinity;

    for (const series of currentChannels) {
        for (const d of series) {
            const dx = xScale(d.date) - mx;
            const dy = yScale(d.count) - my;
            const dist = dx * dx + dy * dy;
            if (dist < minDist) {
                minDist = dist;
                closest = d;
            }
        }
    }

    if (!closest) {
        tooltip.style.visibility = 'hidden';
        return;
    }

    if (!focusLock) {
        focusedChannel = closest.channelName;
        drawLines(currentChannels);
    }

    const tooltipX = xScale(closest.date) + 10;
    const tooltipY = yScale(closest.count) - 10;
    tooltip.style.left = tooltipX + 'px';
    tooltip.style.top = tooltipY + 'px';
    tooltip.style.visibility = 'visible';
    tooltip.innerHTML = `
        <div><b>${closest.channelName}</b></div>
        <div>${d3.utcFormat('%b %d %Y')(closest.date)}</div>
        <div>${closest.count.toFixed()}</div>
    `;
});

canvas.on('mouseleave', () => {
    tooltip.style.visibility = 'hidden';
    if (!focusLock) {
        focusedChannel = null;
        drawLines(currentChannels);
    }
});

canvas.on('click', (event) => {
    if (!currentChannels.length) return;
    const [mx, my] = d3.pointer(event, canvas.node());

    let closest = null;
    let minDist = Infinity;

    for (const series of currentChannels) {
        for (const d of series) {
            const dx = xScale(d.date) - mx;
            const dy = yScale(d.count) - my;
            const dist = dx * dx + dy * dy;
            if (dist < minDist) {
                minDist = dist;
                closest = d;
            }
        }
    }

    if (closest) {
        focusedChannel = focusedChannel === closest.channelName && focusLock ? null : closest.channelName;
        focusLock = !focusLock;
        drawLines(currentChannels);
    }
});

function drawLegend (channels: string[]) {
    legendDiv.innerHTML = '';
    const color = d3.scaleOrdinal(colorRange).domain(channels);

    channels.forEach(ch => {
        const item = document.createElement('a');
        item.onclick = () => {
            focusedChannel = focusedChannel === ch ? null : ch;
            drawLines(currentChannels);
        };
        item.textContent = ch;
        item.style.color = color(ch);
        item.style.cursor = 'pointer';
        item.style.userSelect = 'none';
        item.style.marginRight = '1rem';
        legendDiv.appendChild(item);
    });
}

// Main Func
function updateChart() {
    const interval = intervalSelect.value;
    const windowSize = +windowSizeInput.value;
    const selectedChannel = channelFilterSelect.value;

    let grouped = groupDataByInterval(rawData, interval);

    if (selectedChannel) {
        focusedChannel = null; // reset focus if channel is filtered
        grouped = grouped.filter(arr => arr[0]?.channelName === selectedChannel);
    }

    const smoothed = grouped.map(series => movingAverage(series, windowSize));
    
    if (!smoothed.flat().length) {
        context.clearRect(0, 0, width, height);
        legendDiv.innerHTML = '(No data)';
        return;
    }
    setupScales(smoothed);

    currentChannels = smoothed; // store globally to use in zoom, tooltips
    drawLines(currentChannels);

    const channels = smoothed.map(arr => arr[0]!.channelName).filter(Boolean);
    drawLegend(channels);
}

intervalSelect.addEventListener('change', updateChart);
windowSizeInput.addEventListener('input', updateChart);
channelFilterSelect.addEventListener('change', updateChart);

window.addEventListener('resize', () => {
    width = chartDiv.clientWidth;
    height = Math.floor(width * 0.6);
    canvas
        .attr('width', width)
        .attr('height', height);

    zoomBehavior.translateExtent([
        [margin.left, margin.top],
        [width - margin.right, height - margin.bottom]
    ]);
    d3.select(canvas.node()).call(zoomBehavior as any);

    updateChart();
});

updateChart();
</script>

<style>
    .chartOptions {
        display: flex;
        flex-direction: column;
        gap: var(--line-height);
    }

    #chart {
        position: relative;
        display: flex;
        flex-direction: column;
        gap: var(--line-height);
    }
        
    #tooltip {
        position: absolute;
        pointer-events: none;
        background: rgba(0,0,0,0.8);
        color: #fff;
        padding: 0.5rem;
        font-size: 0.75rem;
        visibility: hidden;
        z-index: 999;
    }

    #legend {
        display: flex;
        gap: var(--line-height);
        flex-wrap: wrap;
        margin-bottom: var(--line-height);
    }
</style>
